#!/usr/bin/env ruby

require 'pathname'
require 'fileutils'
require 'tmpdir'
require 'mkmf'

def usage(error = true)
  out = error ? $stderr : $stdout
  out.puts "#{$PROGRAM_NAME} <output directory> <shader directories...>"
  out.puts ''
  out.puts 'Note: The path to the "glslc" executable can be set with the '\
           'environmental variable "GLSLC_EXE"'
  abort if error
  exit 0
end

def constant_name(path)
  name = path.upcase
  name.gsub!(/[^A-Z0-9]/, '_')
  name.gsub!(/\//, '_')
  name
end

unless ARGV.empty?
  case ARGV[0]
  when '-h', '--help', 'help'
    usage(false)
  end
end

if ARGV.count < 2
  $stderr.puts 'An output file and at least one input file are required'
  usage
end
output = Pathname.new(ARGV[0])
output.dirname.mkdir unless output.dirname.exist?
glslc = begin
  path = ENV['GLSLC_EXE'] || MakeMakefile.find_executable('glslc')
  raise 'Unable to find "glslc" executable' if path.nil? || path.empty?
  Pathname.new(path).expand_path
end

unless glslc.exist?
  $stderr.puts "No such file or directory '#{glslc}'"
  usage
end

unless glslc.executable?
  $stderr.puts "'#{glslc}' is not an executable"
end


slangc = begin
  path = ENV['SLANGC_EXE'] || MakeMakefile.find_executable('slangc')
  raise 'Unable to find "slangc" executable' if path.nil? || path.empty?
  Pathname.new(path).expand_path
end

unless slangc.exist?
  $stderr.puts "No such file or directory '#{slangc}'"
  usage
end

unless slangc.executable?
  $stderr.puts "'#{slangc}' is not an executable"
end

puts "Using glslc: #{glslc}"
puts "Using slangc: #{slangc}"

$shaders = {}
$constants = {}
SLANGC_ARGS = %w[
  -target spirv
  -profile spirv_1_4
  -emit-spirv-directly
  -fvk-use-entrypoint-name
  -entry vert_main
  -entry frag_main
].join(' ')

def compile_shader(slangc, glslc, dir, file)
  Dir.chdir(dir) do
    cmd = ''
    if file.extname == '.slang'
      cmd = "#{slangc} #{file} #{SLANGC_ARGS} -o #{dir}/a.spv"
    else
      cmd = "#{glslc} -g #{file}"
    end
    system(cmd, exception: true)
    Pathname.new('a.spv').open('rb').read
  end
end

def hex(str, i)
  n = str.byteslice(i).ord
  # make sure we pad with leading zero if needed
  "0x#{n.to_s(16).upcase.rjust(2, '0')}"
end

def compile_shaders(slangc, glslc, path)
  path = Pathname.new(path)
  raise "No such file or directory '#{path}'" unless path.exist?
  # name = constant_name(path)
  Dir.mktmpdir do |dir|
    dir = Pathname.new(dir).expand_path
    path.children.each do |c|
      key = Pathname.new(c).relative_path_from(path).to_s
      ext = c.extname.downcase
      next unless %w[.comp .vert .frag .slang].any?(ext)
      c = c.expand_path
      const = constant_name(key)
      raise "Duplicate shaders found for entry '#{key}'" if $shaders.key?(key)
      raise "Constant #{const} already exists!" if $constants.key?(const)
      print "Compiling shader '#{key}' from path '#{c}'..."
      $shaders[key] = {
        constant: const,
        data: compile_shader(slangc, glslc, dir, c)
      }
      $constants[const] = true
      puts " done"
    end
  end
end

input = Pathname.new(ARGV[1])
raise "No such file or directory '#{input}'" unless input.exist?
raise "'#{input}' is not a directory" unless input.directory?
input.dirname.mkpath unless input.dirname.exist?

compile_shaders(slangc, glslc, input)

sorted = $shaders.each_pair.sort_by do |pair|
  pair[1][:constant]
end

progname = Pathname.new($PROGRAM_NAME).basename.to_s

output.open('w') do |fh|
  fh.puts <<EOF
/* SPDX-License-Identifier: ISC */
/* This file was generated by #{progname}. DO NOT EDIT!!! */

#include "euler/vulkan/renderer.h"

#include <array>
#include <cstdint>
#include <optional>
#include <span>
#include <unordered_map>

EOF
  sorted.each do |pair|
    k = pair[0]
    v = pair[1]
    n = v[:data].size
    fh.puts <<EOF
static constexpr std::array<uint8_t, #{n}> #{v[:constant]} = {
	// clang-format off
EOF
    row = 0
    while (n >= 12) do
      fh.write "\t"
      first = true
      (1..12).each do
        if first
          first = false
        else
          fh.write ' '
        end
        i = v[:data].size - n
        n -= 1
        fh.print hex(v[:data], i) + ','
      end
      fh.write "\n"
    end
    fh.write "\t"
    first = true
    (1..n).to_a.reverse.each do |i|
      if first
        first = false
      else
        fh.write ' '
      end
      fh.print hex(v[:data], i) + ','
    end
    fh.write "\n"
    fh.puts <<EOF
	// clang-format on
};
EOF
  end
  fh.puts <<EOF

using Renderer = euler::vulkan::Renderer;

template <size_t N>
static std::pair<std::string_view, Renderer::ShaderData>
make_entry(std::string_view key, const std::array<uint8_t, N> &value)
{
	return std::make_pair(key, value);
}

std::optional<Renderer::ShaderData>
Renderer::load_builtin_shader(const std::string_view key)
{
	static const std::unordered_map<std::string_view, ShaderData> MAP = {
		// clang-format off
EOF
  sorted.each do |pair|
    k = pair[0]
    v = pair[1]
    c = v[:constant]
    fh.puts "\t\tmake_entry(\"#{k}\", #{c}),"
  end
  fh.puts <<EOF
		// clang-format on
	};
	if (MAP.contains(key)) return MAP.at(key);
	return std::nullopt;
}
EOF
end

input.join('mkmf.log').delete if input.join('mkmf.log').exist?

