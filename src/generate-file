#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'singleton'

# this is haphazardly grafted from another project, have mercy on me
class CaseTransformer
  include Singleton

  def add_acronym(acronym)
    @mutex.synchronize do
      @acronyms.add(acronym)
    end
  end

  def with_acronym(acronym, &block)
    already_exists = acronym?(acronym)
    add_acronym(acronym)
    block.call
  ensure
    remove_acronym(acronym) unless already_exists
  end

  def remove_acronym(acronym)
    @mutex.synchronize do
      @acronyms.delete(acronym)
    end
  end

  def acronym?(word)
    @mutex.synchronize do
      @acronyms.include?(word)
    end
  end

  def acronyms
    @mutex.synchronize do
      @acronyms.dup
    end
  end

  def camelize_acronyms=(value)
    @mutex.synchronize do
      @camelize_acronyms = value
    end
  end

  def camelize_acronyms?
    @mutex.synchronize do
      @camelize_acronyms
    end
  end

  def upper?(char)
    /\p{Lu}/.match?(char)
  end

  def lower?(char)
    /\p{Ll}/.match?(char)
  end

  # This is written weirdly (i.e. the + in the middle) because the IDE keeps
  # fussing that these properties don't exist, even though they do (at least
  # in MRI Ruby 3.4.1+)
  ID_CHAR_REGEX = Regexp.new('\p{XID_Start}' + '|' + '\p{XID_Continue}')

  def id_char?(char)
    ID_CHAR_REGEX.match?(char) && char != '_'
  end

  def split_words(str)
    # Word splitting rules, in descending precedence:
    # - Characters outside XID_Start or XID_Continue will not be included
    #   in words, but will be treated as separating words.
    # - Multiple upper case letters in a row will be treated as a single
    #   word
    # - If the next character is upper case, it's treated as the start of a
    #   new word
    str = str.to_s
    words = []
    word = ''
    is_upper = false
    upper_chain = false
    str.each_char do |c|
      if id_char?(c)
        current_upper = upper?(c)
        if !current_upper && upper_chain
          words << word[0..-2] unless word.length < 2
          word = word[-1] || ''
          word += c
          upper_chain = false
          is_upper = false
          next
        end
        upper_chain = (current_upper || upper_chain) && !word.empty?
        if !is_upper && upper?(c)
          words << word unless word.empty?
          word = ''
        end
        word += c
        is_upper = upper?(c)
      else
        words << word unless word.empty?
        word = ''
      end
    end
    words << word unless word.empty?
    words
  end

  def to_delimited(str, delimiter)
    split_words(str).join(delimiter)
  end

  def to_snake(str)
    to_delimited(str, '_').downcase
  end

  def to_kebab(str)
    to_delimited(str, '-').downcase
  end

  def to_screaming_snake(str)
    to_delimited(str, '_').upcase
  end

  def to_screaming_kebab(str)
    to_delimited(str, '-').upcase
  end

  def to_camel(str)
    words = split_words(str)
    words[0].downcase + words[1..].map do |w|
      if acronym?(w)
        w.upcase
      else
        w.capitalize
      end
    end.join
  end

  def to_pascal(str)
    split_words(str).map do |w|
      if acronym?(w) && !camelize_acronyms?
        w.upcase
      else
        w.capitalize
      end
    end.join
  end

  def self.to_snake(str)
    instance.to_snake(str)
  end

  def self.to_kebab(str)
    instance.to_kebab(str)
  end

  def self.to_screaming_snake(str)
    instance.to_screaming_snake(str)
  end

  def self.to_screaming_kebab(str)
    instance.to_screaming_kebab(str)
  end

  def self.to_camel(str)
    instance.to_camel(str)
  end

  def self.to_pascal(str)
    instance.to_pascal(str)
  end

  def self.split_words(str)
    instance.split_words(str)
  end

  def self.to_delimited(str, delimiter)
    instance.to_delimited(str, delimiter)
  end

  def self.add_acronym(acronym)
    instance.add_acronym(acronym)
  end

  private

  def initialize
    @acronyms = Set.new
    @mutex = Mutex.new
    @camelize_acronyms = false
  end
end

CaseTransformer.instance

class ClassCreator
  attr_reader :name
  attr_reader :no_class

  def initialize(name:, namespace: %i[euler], no_class: false)
    @name = name
    @namespace = namespace.map do |ns|
      if ns.to_s.downcase == 'mruby'
        'mruby'
      else
        CaseTransformer.to_pascal(ns)
      end
    end
    @no_class = no_class
  end

  def camel_case
    @camel_case ||= name.split('_').map(&:capitalize).join
  end

  def header_guard
    @header_guard ||= "#{namespace.join('_').upcase}_#{name.upcase}_H"
  end

  def namespace
    @namespace.map do |ns|
      if ns.to_s.downcase == 'mruby'
        'MRuby'
      else
        CaseTransformer.to_pascal(ns)
      end
    end
  end

  def self.directory_name(namespace)
    #    ns.map { |s| s.to_s.downcase }
    namespace.map do |ns|
      if ns.to_s.downcase == 'mruby'
        'mruby'
      else
        CaseTransformer.to_snake(ns)
      end
    end
  end

  def directory
    dirname = self.class.directory_name(namespace)
    @relative_directory ||= File.join(dirname.map(&:to_s))
  end

  def header_path
    @header_path ||= File.join(directory, "#{name}.h")
  end

  def source_path
    @source_path ||= File.join(directory, "#{name}.cpp")
  end


  def header
    @header ||= <<~END_SRC
      /* SPDX-License-Identifier: ISC */

      #ifndef #{header_guard}
      #define #{header_guard}

      namespace #{namespace.join('::')} {
      #{no_class ? '' : "class #{camel_case} { };"}
      } /* namespace #{namespace.join('::')} */

      #endif /* #{header_guard} */

    END_SRC
  end

  def source
    @source ||= <<~END_SRC
      /* SPDX-License-Identifier: ISC */

      #include "#{header_path}"

    END_SRC
  end

  def create
    FileUtils.mkdir_p(directory)
    puts "Writing #{header_path}..."
    File.write(header_path, header)
    puts "Writing #{source_path}..."
    File.write(source_path, source)
  end
end

if ARGV.size < 1 || ARGV.size > 2
  puts "Usage: make_class.rb [--no-class] <class_name>"
  exit
end

def to_snake_case(str)
  str.gsub(/([A-Z])/) { |m| "_#{m.downcase}" }.sub(/^_/, '')
end

arg = ARGV[0]

no_class = false

if arg == '--no-class'
  no_class = true
  arg = ARGV[1]
end

parts = arg.split('::')

namespace = parts[0..-2].map(&:to_sym) if parts.size > 1

args = {
  name: to_snake_case(parts[-1]),
  no_class: no_class
}

args[:namespace] = namespace if namespace

cc = ClassCreator.new(**args)

cc.create
